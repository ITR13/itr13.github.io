---
layout: default
---
<div class="search-container">
    <input type="text" id="searchInput" placeholder="Search / Filter..">
</div>

<div class="info-boxes horizontal">
    <div class="info-box">
        <div class="title">Level</div>
        <input type="number" id="level" min="1" max="100" value="100">
    </div>
    <div class="info-box">
        <div class="title">Stars</div>
        <input type="number" id="stars" min="0" max="900" value="900">
    </div>
    <div class="info-box">
        <div class="title">Hearts</div>
        <input type="number" id="hearts" min="1" max="14" value="1">
    </div>
    <div class="info-box">
        <div class="title">Fossils</div>
        <input type="number" id="fossils" min="0" max="7" value="6">
    </div>
</div>

<div id="loadingBar">Loading Pokémon...</div>
<div id="rankTableContainer"></div>

<style>
    .info-boxes.horizontal {
        display: flex;
        gap: 12px;
        margin-bottom: 12px;
    }

    .info-box {
        background: #33333355;
        padding: 8px 12px;
        border-radius: 8px;
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .info-box .title {
        font-weight: bold;
        margin-bottom: 4px;
    }

    table {
        border-collapse: collapse;
        width: 100%;
    }

    th,
    td {
        border: 1px solid #ccc;
        padding: 4px 8px;
    }

    th {
        cursor: pointer;
        background: #222;
        color: #fff;
        position: relative;
    }

    th .sort-arrow {
        font-size: 0.8em;
        margin-left: 4px;
    }

    td.num {
        text-align: right;
    }

    #loadingBar {
        margin: 12px 0;
        font-weight: bold;
    }
</style>

<script>
    document.addEventListener('DOMContentLoaded', async () => {
        const container = document.getElementById('rankTableContainer');
        const searchInput = document.getElementById('searchInput');
        const levelInput = document.getElementById('level');
        const starsInput = document.getElementById('stars');
        const heartsInput = document.getElementById('hearts');
        const fossilsInput = document.getElementById('fossils');
        const loadingBar = document.getElementById('loadingBar');

        let sortKey = 'name';
        let sortAsc = true;

        loadingBar.style.display = 'block';
        const data = await fetch('data.json').then(r => r.json());
        loadingBar.style.display = 'none';

        function stat(obj, key, level) {
            const base = obj?.[key]?.base ?? 0;
            const scale = obj?.[key]?.scale ?? 0;
            return Math.floor(base + scale * level);
        }

        function spawnVariants(p) {
            const level = +levelInput.value;
            const stars = +starsInput.value;
            const hearts = +heartsInput.value;
            const fossils = +fossilsInput.value;

            const variants = p.name != "Lycanroc" ? [{ name: p.name, mods: {} }] : [];

            let offsetId = -1;

            if (['ambusher', 'castform'].includes(p.ability))
                variants.push({ name: p.name + ' (grass)', mods: { id: offsetId--, power: 2 } });
            if (['swimmer', 'castform'].includes(p.ability))
                variants.push({ name: p.name + ' (water)', mods: { id: offsetId--, speed: 0.5 } });
            if (['vigilant', 'castform'].includes(p.ability))
                variants.push({ name: p.name + ' (mountain)', mods: { id: offsetId--, range: 2 } });

            if (p.ability === 'toughClaws') {
                variants.push({ name: p.name + ' (mountain)', mods: { id: offsetId--, power: 1.5 } });
                variants.push({ name: p.name + ' (grass)', mods: { id: offsetId--, critical_add: 1 } });
            }
            else if (p.ability === 'toughClawsDay') {
                variants.push({ name: p.name + ' (day)', mods: { id: offsetId-- } });
                variants.push({ name: p.name + ' (mountain, day)', mods: { id: offsetId--, power: 1.5, critical_set: 1 } });
            }
            else if (p.ability === 'toughClawsNight') {
                variants.push({ name: p.name + ' (night)', mods: { id: -8 } });
                variants.push({ name: p.name + ' (grass, night)', mods: { id: offsetId--, power: 1.5, critical_set: 1 } });
            }
            else if (['doubleShotSand', 'quadtrraShotSand'].includes(p.ability))
                variants.push({ name: p.name + ' (route 2)', mods: { id: offsetId--, range: 2 } });
            else if (p.ability === 'speedBoost') {
                variants.push({ name: p.name + ' (max boost)', mods: { id: offsetId--, speed_add: -3 } });
            }
            else if (p.ability === 'sniper') {
                variants.push({ name: p.name + ' (max dist)', mods: { id: offsetId--, power: 2 ** (Math.floor(p.range / 120)) * 2 } });
            }
            else if (p.ability === 'moxie') {
                variants.push({ name: p.name + ' (10 moxies)', mods: { id: offsetId--, power: 1.3 } });
            }
            else if (p.ability === 'moxie') {
                variants.push({ name: p.name + ' (20 moxies)', mods: { id: offsetId--, power: 1.6 } });
            }
            else if (p.ability === 'chatter') {
                variants.push({ name: p.name + ' (max volume)', mods: { id: offsetId--, power: 2 } });
            }
            else if (p.ability === 'stanceChange') {
                variants.push({ name: p.name + ' (shield)', mods: { id: offsetId--, power: 0.5, area: true } });
            }
            else if (p.ability === 'fieryDance') {
                variants.push({ name: p.name + ' (burnt enemies)', mods: { id: offsetId--, power: 2 } });
            }

            // Items

            if (p.id == 70) {
                // Skip ditto
                return variants.map(v => ({ base: p, ...v }));
            }

            const existingVariants = [...variants];

            if (![19, 70, 83].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (protein)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power_add: (v.mods.power_add ?? 0) + 10
                        }
                    });
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (carbos)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            speed: (v.mods.speed ?? 1) * 0.85
                        }
                    });
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (quick claw)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 0.5,
                            speed: (v.mods.speed ?? 1) * 0.5
                        }
                    });
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (heart scale)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 0.5,
                            speed: (v.mods.speed ?? 1) * 0.5
                        }
                    });
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (ditto, quick powder)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 0.5,
                            speed: (v.mods.speed ?? 1) * 0.75
                        }
                    });
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (ditto, metal powder)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.5,
                            speed: (v.mods.speed ?? 1) * 1.25
                        }
                    });
                }

                for (const v of existingVariants) {
                    if (p.critical > 0 || ((v.critical ?? 0) > 0) || ((v.critical_add ?? 0) > 0) || ((v.critical_set ?? 0) > 0)) {
                        let critical = p.critical * (v.critical ?? 1) + (v.critical_add ?? 0);
                        if (v.critical_set) critical = v.critical_set;

                        variants.push({
                            name: v.name + ' (blue bandana)',
                            mods: {
                                ...v.mods,
                                id: offsetId--,
                                power: (v.mods.power ?? 1) * (1 + 0.0175 * critical),
                                critical_set: 0
                            }
                        });
                    }
                }

                if (heartsInput <= 7) {
                    for (const v of existingVariants) {
                        variants.push({
                            name: v.name + ' (adrenaline orb)',
                            mods: {
                                ...v.mods,
                                id: offsetId--,
                                speed: (v.mods.speed ?? 1) * 0.75
                            }
                        });
                    }
                }

                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (badge of honor)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * (1 + stars / (3000)),
                        }
                    });
                }
            }

            if (p.id === 57) {
                variants.push({ name: p.name + ' (leek)', mods: { id: offsetId--, power: 2, crit_power: 2 } });
            }
            else if (p.id === 45) {
                variants.push({ name: p.name + ' (club)', mods: { id: offsetId--, power: 1.5 } });
            }
            else if (p.id === 72) {
                variants.push({ name: p.name + ' (light ball)', mods: { id: offsetId--, power: 1.5 } });
            }
            else if (p.id === 29) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (bullet)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            speed_add: (v.mods.speed_add ?? 0) + 2
                        }
                    });
                }
            }
            else if (p.id === 63) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (claw fossil)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * (1 + fossils * 0.05)
                        }
                    });
                }
            }
            else if ([21, 23, 27, 88].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (life orb)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.5,
                            speed: (v.mods.speed ?? 1) * 0.5
                        }
                    });
                }
            }
            else if (p.id === 59) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (dome fossil)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            critical_add: (v.mods.critical_add ?? 0) + 0.05 * fossils,
                        }
                    });
                }
            }
            else if (p.id === 66) {
                // Handled in damage calc
                variants.push({ name: p.name + ' (rocky helmet)', mods: {} });
            }

            if ([58, 59, 63, 64, 65, 66].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (hard stone)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.2,
                        }
                    });
                }
            }
            if ([24, 37, 47, 51, 56, 59, 67, 75, 85].includes(p.id)) {
                let speedMult = 0.8;
                if (p.ability === 'quadraShot' || p.ability === 'quadraShotSand') speedMult = 0.4;
                else if (p.ability === 'tripleShot') speedMult = 0.6;
                variants.push({ name: p.name + ' (club)', mods: { id: offsetId--, speed: speedMult } });
            }

            if (p.attackType === 'area') {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (soft sand)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.2,
                        }
                    });
                }
            }
            else if (p.attackType === 'single') {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (sniper scope)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.2,
                        }
                    });
                }
            }

            if (p.ricochet > 0) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (loaded dice)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * Math.floor(Math.sqrt(p.ricochet * 0.5)),
                        }
                    });
                }
            }

            if (p.ricochet > 0 && [2, 45, 63, 72].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (metronome)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.15,
                        }
                    });
                }
            }

            if ([10, 16, 51, 73, 86].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (strange idol)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            power: (v.mods.power ?? 1) * 1.1,
                        }
                    });
                }
            }

            if ([6, 14, 25, 56].includes(p.id)) {
                for (const v of existingVariants) {
                    variants.push({
                        name: v.name + ' (poison barb)',
                        mods: {
                            ...v.mods,
                            id: offsetId--,
                            speed: (v.mods.speed ?? 1) * 0.8,
                        }
                    });
                }
            }

            return variants.map(v => ({ base: p, ...v }));
        }

        function buildRows() {
            const rows = [];
            for (const [id, p] of Object.entries(data.pokemon)) {
                spawnVariants(p).forEach(v => rows.push(v));
            }
            return rows;
        }

        function compute(row) {
            const level = +levelInput.value;
            const stars = +starsInput.value;
            const hearts = +heartsInput.value;
            const fossils = +fossilsInput.value;

            let speed = stat(row.base, 'speed', level) / 1000;
            let power = stat(row.base, 'power', level);
            let range = stat(row.base, 'range', level);
            let critical = stat(row.base, 'critical', level) / 100;
            const abilityKey = row.base.ability;
            const ability = data.ability[abilityKey];

            if (row.base.ability === 'star') power += stars;
            if (row.base.ability === 'bastiodon') speed -= 0.5 * fossils;
            if (row.base.ability === 'rampardos') {
                if (row.name.includes("rocky helmet")) {
                    power *= (1 + 0.1 * (14 - hearts));
                } else {
                    power *= (1 + 0.05 * (14 - hearts));
                }
            }

            if (row.mods.power_add) power += row.mods.power_add;
            if (row.mods.speed_add) speed += row.mods.speed_add;
            if (row.mods.range_add) range += row.mods.range_add;
            if (row.mods.critical_add) critical += row.mods.critical_add;

            if (row.mods.critical_set) critical = row.mods.critical_set;

            if (row.mods.power) power *= row.mods.power;
            if (row.mods.speed) speed *= row.mods.speed;
            if (row.mods.range) range *= row.mods.range;
            if (row.mods.critical) critical *= row.mods.critical;

            critical = Math.max(0, Math.min(1, critical));

            let critBase = row.base.ability === 'superCritical' ? 2 : 1.5;
            if (row.mods.critical_power) critBase *= row.mods.critical_power;

            const dps = Math.ceil(
                power * ((1 - critical) + critical * critBase)
            ) / speed;

            const dpsCrit = Math.ceil(
                power * ((1 - critical) + critical * (critBase * 1.33))
            ) / speed;

            let stunChance = 0;
            if (['stunMono', 'stunArea'].includes(row.base.ability)) stunChance = 0.3;
            if (['stunMonoNerf', 'static'].includes(row.base.ability)) stunChance = 0.05;

            const sps = stunChance ? speed / stunChance : null;

            const evoLevel = row.base.evolution?.level ?? 101;

            const rangeType = (row.base.attackType == "area" || row.mods.area) ? "area" : row.base.rangeType;

            let id = row.base.id;
            if (row.mods.id != null) {
                id *= -64
                id += row.mods.id;
            }

            return {
                name: row.name,
                ability: ability.name,
                abilityDesc: ability.description,
                speed,
                power,
                range,
                critical,
                dps,
                dpsCrit,
                sps,
                id: id,
                evoLevel,
                rangeType: rangeType,
            };
        }

        function filterEvolutionLines(rows) {
            const level = +levelInput.value;
            const grouped = {};
            for (const r of rows) {
                if (!grouped[r.id]) grouped[r.id] = [];
                grouped[r.id].push(r);
            }

            const filtered = [];
            // Filter to just show one pokemon per evolution line
            for (const group of Object.values(grouped)) {
                const candidates = group.filter(r => r.evoLevel > level);
                if (!candidates.length) continue;

                const chosen = candidates.reduce((a, b) =>
                    a.evoLevel < b.evoLevel ? a : b
                );

                filtered.push(chosen);
            }


            return filtered;
        }

        function render() {
            const query = searchInput.value.toLowerCase();
            let rows = buildRows()
                .map(compute)
                .filter(r =>
                    r.name.toLowerCase().includes(query) ||
                    r.ability.toLowerCase().includes(query) ||
                    r.abilityDesc.toLowerCase().includes(query) ||
                    r.rangeType.toLowerCase().includes(query)
                );

            rows = filterEvolutionLines(rows);

            rows.sort((a, b) => {
                const av = a[sortKey];
                const bv = b[sortKey];


                const isEmpty = v =>
                    v === null ||
                    v === undefined ||
                    v === '' ||
                    (typeof v === 'number' && Number.isNaN(v));

                const aEmpty = isEmpty(av);
                const bEmpty = isEmpty(bv);

                if (aEmpty && bEmpty) return 0;
                if (aEmpty) return 1;
                if (bEmpty) return -1;

                if (typeof av === 'number' && typeof bv === 'number') {
                    return sortAsc ? av - bv : bv - av;
                }

                return sortAsc
                    ? String(av).localeCompare(String(bv))
                    : String(bv).localeCompare(String(av));
            });


            let html = `<table>
<thead><tr>`;
            const headers = [
                { key: 'name', label: 'Name' },
                { key: 'ability', label: 'Ability' },
                { key: 'speed', label: 'Recharge (s)' },
                { key: 'power', label: 'Power' },
                { key: 'range', label: 'Range' },
                { key: 'critical', label: 'Crit %' },
                { key: 'dps', label: 'DPS', title: 'Damage per second' },
                { key: 'dpsCrit', label: 'DPS Crit+', title: 'DPS inside Critical Aura' },
                { key: 'sps', label: 'SPS', title: 'Seconds per Stun' },
            ];
            headers.forEach(h => {
                html += `<th onclick="sort('${h.key}')" title="${h.title ?? ''}">${h.label}${sortKey === h.key ? ` <span class="sort-arrow">${sortAsc ? '▲' : '▼'}</span>` : ''}</th>`;
            });
            html += `</tr></thead><tbody>`;

            rows.forEach(r => {
                html += `<tr>
<td style="text-transform: capitalize;">${r.name}</td>
<td style="text-transform: capitalize;" title="${r.abilityDesc}">${r.ability}</td>
<td class="num">${r.speed.toFixed(2)}</td>
<td class="num">${r.power.toFixed(0)}</td>
<td class="num">${r.range.toFixed(0)} (${r.rangeType})</td>
<td class="num">${(r.critical * 100).toFixed(0)}%</td>
<td class="num">${r.dps.toFixed(2)}</td>
<td class="num">${r.dpsCrit.toFixed(2)}</td>
<td class="num">${r.sps ? r.sps.toFixed(2) : ''}</td>
</tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        window.sort = key => {
            sortAsc = sortKey === key ? !sortAsc : true;
            sortKey = key;
            render();
        };

        [searchInput, levelInput, starsInput, heartsInput, fossilsInput].forEach(e =>
            e.addEventListener('input', render)
        );

        render();
    });
</script>